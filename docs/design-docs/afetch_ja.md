# Overview

`afetch` (Asynchronous FETCH utilities) は `aiohttp` をベースにしたミニマルな非同期 HTTP クライアントであり、ネットワーキングスタック全体を維持する余力がない小規模チーム（あるいは個人開発者）でも信頼性の高いフェッチ基盤を扱えるように設計している。レート制限、リトライ、キャッシュといった必須の仕組みを標準搭載することで、負荷が揺らぐ状況でも予測しやすい挙動を提供する。

現在の 0.x 系は `Fetcher` 抽象のプロダクション適用に向けた堅牢化と、内部で使いながら蓄積してきたパターンの言語化を主眼に置く。アーキテクチャ上の意図を早い段階で文書化しておけば、将来の自分や協力者が並行性・キャッシュ・観測性に関する意思決定を再確認する際のコストを削減できる。

本ドキュメントでは、現行コンポーネントのつながり、今後導入予定の `request()` / レスポンスハンドラモデルへの漸進的な移行計画、および低コスト運用のために受け入れているトレードオフを整理する。

## Context

- grequests
- requests-futures
- scrapy

`scripts` や軽量サービス向けに信頼できるフェッチユーティリティを用意したい、というのが `afetch` 立ち上げのきっかけである。初期実装では以下の運用課題が繰り返し顕在化した。

1. **ドメイン単位のバースト**: レート制限を考慮しないと 429/503 が頻発した。
2. **一過性の失敗**: ネットワーク断や 5xx が混ざると、手作業でのリトライ調整が煩雑だった。
3. **重複リクエスト**: 静的エンドポイントへのアクセスをキャッシュすれば待ち時間とクォータ消費を大幅に抑えられた。

既存選択肢（素の `aiohttp`、`requests` ベースのラッパー、大規模 SDK など）は、毎回これらクロスカッティングな懸念に手を入れる必要があるか、あるいは依存が大きすぎると感じられた。`afetch` は軽量さを保ちながらこれらのニーズを取り込むことを目指す。

## Scope

本ドキュメントでは以下を扱う。

- 現行 `Fetcher` 実装のランタイム構造。
- `FetcherConfig` の設定項目とレート制限・リトライ・キャッシュの連携。
- 汎用的な `request()` とレスポンスハンドラ導入に向けたロードマップ（詳細はレスポンス処理設計書参照）。
- ロギング、メトリクス、展開単位などの運用上の考慮事項。

対象外：

- `aiohttp` のプロトコル挙動や TLS・コネクションプール内部の詳細。
- 組織横断のリリースフローやツール連携（README および別資料で扱う）。
- `afetch` 出力を利用するドメイン固有処理。

## Goal

- レート制限・リトライ・キャッシュの複雑性を隠蔽しつつ、失敗モードが推測しやすい抽象を提供する。
- `async with Fetcher(): ...` という一貫した利用形態を保証し、リソース管理を単純化する。
- 既存の `fetch` / `fetch_all` API を維持しながら、ハンドラベースのレスポンスモデルの導入準備を進める。
- メンテナンスしやすい依存パッケージ群に限定し、アップグレードやサプライチェーンリスクを小さく保つ。

## Non-Goal

- 同期 API への対応や `urllib` / `requests` の完全な代替。
- 任意のフックを注入できるミドルウェアスタックの提供（現状は設定パラメータに限定）。
- サービスメッシュ的な全社インフラコンポーネント化（あくまでクライアントサイドのユーティリティ）。

## Solution / Technical Architecture

アーキテクチャの中心は `Fetcher` クラスであり、キャッシュ・リトライ・ドメイン単位レート制限という 3 要素のライフサイクルを統合管理する。初期化時の煩雑さを最小化するため、設定は `FetcherConfig` dataclass に集約している。

主な設計判断は以下の通り。

1. **非同期コンテキストの強制**: `async with` 以外での利用を拒否し、キャッシュ済みセッションやリトライクライアントのクリーンアップ漏れを防ぐ。
2. **ドメイン別リミッタ**: ドメインをキーとした `aiolimiter.AsyncLimiter` の辞書を使い、公平性を保ちつつドメイン間の直列化を避ける。
3. **キャッシュ戦略**: デフォルトで `aiohttp-client-cache` のファイルバックエンドを採用し、設定で簡単に無効化可能。
4. **リトライクライアント**: `aiohttp_retry.RetryClient` をラップし、指数バックオフと試行回数を構成可能にする。

### System Context Diagrams

- **クライアントコード**（スクリプトや軽量サービス）が `Fetcher` を生成し URL を渡す。
- **Fetcher** は以下を組み合わせる：
    - `CachedSession`（`aiohttp-client-cache`）: キャッシュ永続化。
    - `RetryClient`（`aiohttp_retry`）: バックオフ付きリトライ。
    - `AsyncLimiter`（`aiolimiter`）: 同時実行の抑制。
- **外部システム**：
    - 対象の HTTP サービス群。
    - ローカルファイルシステム（デフォルトキャッシュ `.afetch_cache`）。
    - `FetcherConfig` 経由で渡されるカスタムキャッシュバックエンド。

Fetcher は内部セッションを直接公開せず、誤用可能性を下げている。

### APIs

- `Fetcher(config: FetcherConfig | None = None)`
    - メソッド:
        - `async fetch(url: str | URL) -> str`
        - `async fetch_all(urls: Iterable[str | URL]) -> list[str]`
        - 非同期コンテキストマネージャ（`__aenter__`, `__aexit__`）
- `FetcherConfig` の主なフィールド:
    - `max_rate_per_domain: int`
    - `time_period_per_domain: float`
    - `retry_attempts: int`
    - `cache_backend: CacheBackend | None`
    - `cache_enabled: bool`
- **今後の追加予定**（レスポンス設計書と連動）:
    - `Fetcher.request()` が拡張可能なレスポンス抽象を返す。
    - キャッシュやリトライを共有しつつデコード戦略を切り替えるハンドラインターフェース。

既存の `fetch()` はすぐには置き換えず、段階的に新 API を併設する。

### Data Storage

- デフォルトキャッシュは `.afetch_cache` 配下のファイルバックエンド（`FetcherConfig` で変更可）。
- キャッシュエントリにはリクエストメタデータとシリアライズ済みレスポンスボディを含み、有効期限はバックエンドの設定で制御する。
- バックエンド以上の永続化レイヤーは持たず、独自スキーマやマイグレーションは不要。
- Redis など別ストレージが必要な場合は互換バックエンドを注入する。

## Alternative Solution

| 案                      | 内容                                                     | 長所                                                                 | 短所                                                                                       |
| ----------------------- | -------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| 現状維持 (`fetch` のみ) | 既存の `fetch` / `fetch_all` API を恒久的に使い続ける。  | 実装コスト最小。既存スクリプトは安定。                               | バイナリ／ストリーミング用途へ拡張しづらく、利用者がデコード処理を毎回実装する必要がある。 |
| `aiohttp` 直接公開      | `ClientSession` を呼び出し側に返し、制御を委譲する。     | 柔軟性最大。余分な抽象が増えない。                                   | レート制限やキャッシュを利用者が毎回実装する必要があり、リソースリークのリスクが高い。     |
| 提案中のハンドラモデル  | `request()` とプラガブルなレスポンスハンドラを導入する。 | 柔軟性と安全性のバランスが良く、レスポンスメタデータを標準化できる。 | 学習コストが僅かに増え、追加ドキュメントとテストが必要。                                   |

レスポンス設計書で詰めているハンドラ案を採用しつつ、移行期間は `fetch` を併存させる。

## Milestones

- **2024-07-15** — `FetcherConfig` のインターフェースを固め、設定パターンを文書化。
- **2024-07-29** — メトリクス連携を見据えたロギングフックを整備（`async with Fetcher` の計測ポイント）。
- **2024-08-12** — `request()` プロトタイプとテキスト/JSON/バイナリハンドラを実装（レスポンス設計書との整合）。
- **2024-08-26** — `afetch` v1.0.0 をリリースし、旧 API と新ハンドラ API の両立版ドキュメントを公開。
- **更新ポリシー** — スケジュール変更時は `[Update: YYYY-MM-DD]` を付して追記する。

## Concerns

- **リソース使用量**: ファイルキャッシュが肥大化しやすい。ガイドラインや自動クリーンアップ戦略が必要。
- **並行制御**: ドメイン単位リミッタは善意の利用を想定しており、ワイルドカードサブドメインを多用されると抜け道になる。
- **依存関係のドリフト**: `aiohttp` などアップストリーム更新が速いため、バージョン管理とアップグレード周期の確保が課題。

## Logs

- 当面は `aiohttp` やキャッシュの標準ロガーに委ね、Python 標準ログ設定で制御する。
- 中期的にはキャッシュヒット/ミス、リトライ試行などの構造化イベントをコールバック経由でフックできるようにする。
- デフォルトでは機微ヘッダーやボディをログ出力しない設計を徹底する。

## Security

- TLS 証明書や秘密情報を設定に直書きせず、環境変数など外部注入を推奨する。
- キャッシュはデフォルトで有効だがファイルシステム依存のため、機微データを扱う場合は無効化または暗号化バックエンドの利用を促す。
- 不正な URL による SSRF を防ぐため、アプリケーション側でのバリデーション方針を明示する。

## Observability

- 成功/失敗リクエスト数、リトライ回数、キャッシュヒット率などのメトリクスを将来的に収集できるフックを提供し、Prometheus や OpenTelemetry へ容易に連結できるようにする。
- 各リクエストを span でラップし、ドメイン・試行回数・キャッシュ利用状況などの属性を記録するトレース対応を検討中。

## References

- `docs/design-docs/response.md` — レスポンス処理アーキテクチャ。
- `README.md` — 機能概要と公開情報。
- `src/afetch/fetcher.py` / `config.py` — 実装のソースコード。
- 依存ライブラリ:
    - `aiohttp` ドキュメント
    - `aiohttp-client-cache` ドキュメント
    - `aiohttp-retry` ドキュメント
