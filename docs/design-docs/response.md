# Overview

afetch v1.0.0 で導入するレスポンス処理基盤の目標と方針を共有し、チーム全員が仕様を理解できるようまとめる。

新しい `request()` API とレスポンスハンドラ方式により、従来の `fetch()` の機能を維持しつつ、多様なレスポンス形式のニーズに対応させる。

大容量レスポンスやメモリ制約、キャッシュやロギングとの統合に関する意思決定を明文化し、後続の実装とレビューを円滑にする。

# Context

現行の `fetch()` はテキスト中心の GET 用途に特化しており、レスポンスボディを `str` で返す。

実際のスクレイピングでは複雑なヘッダを伴う REST API へのリクエストや、POST/PUT/PATCH など多様なメソッドが必要であり、さらにレスポンス処理の柔軟性が求められている。

v1.0.0 ではメソッドやヘッダーを柔軟に扱える `request()` と `RequestOptions`、ユーザが自由にレスポンスを処理できるレスポンスハンドラの導入を計画している。

# Scope

本ドキュメントはレスポンス処理の API 設計、ハンドラ体系、メモリ対策、ログ/キャッシュ連携に関する仕様を対象とする。

ネットワーク層の詳細、リトライ戦略、キャッシュ実装細部は本文書では扱わない。

# Goal

- `request()` が返すレスポンスの型と振る舞いを統一し、利用者に明確な期待値を提供する。
- テキスト・JSON・バイナリなど一般的なデコード操作をワンステップで実行できるヘルパーを提供する。
- 構造化ログ、キャッシュ、リトライと連携可能なメタデータをレスポンスに保持する。

# Non-Goal

- 大容量レスポンスを安全に扱うためのガードレール（例: デフォルトボディサイズ制限）の詳細設計はここでは扱わない。
- ストリーミングレスポンスの完全なインターフェース設計は後続課題とする。
- HTTP クライアントの低レベル実装（接続プール、TLS 設定）の見直しは行わない。依存ライブラリ `aiohttp` に委ねるものとする。

# Solution / Technical Architecture

本設計ではレスポンスハンドラ中心のアプローチを採用する。

`request()` は `ResponseHandler` を受け取り、ハンドラが返す任意の値を呼び出し元へ返却する。あるいは、ハンドラ内で適宜ファイルに保存するなどの処理も可能とする。

標準ハンドラは即時ボディ取り込みで `FetcherResponse` を構築し、共通メタデータとアクセサを提供する。

`fetch()` はテキスト返却をデフォルトとしつつ、`FetcherResponse` を返すハンドラを利用者が選択できるようにする。

## System Context Diagrams

- `Fetcher`（本ライブラリ）が `aiohttp` を通じて外部 HTTP サービスと通信する。
- レスポンスハンドラは `Fetcher` 内部で実行され、結果をアプリケーション層へ返す。
- キャッシュストア（`aiohttp-client-cache` など）およびログ/メトリクス基盤が周辺システムとして連携する。

## APIs

- `ResponseHandler` プロトコル
    - 入力: `ResponseContext`（ステータス、ヘッダー、レイテンシ、`aiohttp.ClientResponse`）
    - 戻り値: 任意型（同期/非同期両対応を検討中）
- 標準ハンドラ
    - `TextResponseHandler`：UTF-8 デコードして `str` を返す。
    - `JsonResponseHandler`：`json.loads` で `dict` / `list` を返す。
    - `BytesResponseHandler`：`bytes` を返す。
    - `FetcherResponseHandler`：`FetcherResponse` を返す。
- `FetcherResponse` インターフェース
    - プロパティ: `status`, `headers`, `url`, `elapsed`, `from_cache`, `attempts`, `body_bytes`.
    - メソッド: `.text(encoding=None)`, `.json(**kwargs)`, `.bytes()`, `.raise_for_status()`, 将来の `.iter_chunks(size)`。

## Data Storage

- 永続ストレージは対象外だが、レスポンスキャッシュとの相互運用を考慮する。
- キャッシュ層は完全展開済みボディを保持する前提で設計し、`FetcherResponse` が同一メタデータ構造で扱えるようにする。

# Alternative Solution

| 案          | 内容                                                | 長所                                                                        | 短所                                                               |
| ----------- | --------------------------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| オプションA | レスポンスを即時に読み込み `FetcherResponse` を返す | シンプルで誤用が少ない。キャッシュと親和性高い。                            | 大容量レスポンスでメモリを圧迫。ストリーミング不可。               |
| オプションB | `aiohttp.ClientResponse` を遅延ラップ               | メモリ効率的。ストリーミング拡張が容易。                                    | ライフサイクル管理が難しく誤用リスク高。キャッシュとの整合が複雑。 |
| オプションC | レスポンスハンドラで戻り値を決定                    | 柔軟性高く用途に応じて切り替え可能。デフォルトで `FetcherResponse` も提供。 | 戻り値が多様になり型の統一が難しい。学習コストが上がる。           |

オプションCを採用し、標準ハンドラで即時取り込みの利便性を維持しつつ、他案の利点（ストリーミング等）をカスタムハンドラで補完する。

# Milestones

- 開始日: 2025年12月6日 — 設計確定レビュー完了
- マイルストーン1: 2025年12月10日 — `FetcherResponse` と標準ハンドラの実装・単体テスト完了
- マイルストーン2: 2025年12月12日 — 構造化ログとキャッシュ統合テスト完了
- 終了日: 2025年12月13日 — ドキュメント更新と最終レビュー完了

# Concerns

# Logs

- `FetcherResponse` に `request_id`, `status`, `elapsed`, `from_cache`, `attempts`, `handler_name` を保持し、ロガーへ構造化出力する。

# Security

- レスポンスヘッダーやボディに含まれる機微情報はデフォルトでログに出さない。
- キャッシュへの保存時に HTTPS の暗号化を前提とし、レスポンスは `cache_enabled=False` で回避できるようにする。

# Observability

- メトリクス: レスポンスサイズ分布、ハンドラ別処理時間、ストリーミングチャンク数を `Prometheus` 互換で出力。
- トレース: `request()` 実行時に span を生成し、ハンドラ処理を子 span として紐付ける。

# References

- `docs/requirements_spec.md` — v1.0.0 要求仕様書
- `docs/design-docs/afetch.md` — API 全体設計
- `aiohttp` ドキュメント（レスポンスストリーミング）
